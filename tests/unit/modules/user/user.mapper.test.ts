import { describe, expect, it } from 'bun:test';

import type { DbUser } from '@/modules/user/infrastructure/persistence/user.db-schemas';

import { userMapper } from '@/modules/user/application/dto/user.mapper';
import { User } from '@/modules/user/domain/entities/user.entity';

describe('userMapper', () => {
  const mockUserProps = {
    id: 1,
    email: 'test@example.com',
    name: 'John Doe',
    role: 'user' as const,
    status: 'active' as const,
    isEmailVerified: false,
    passwordHash: 'hashed_password_123',
    createdAt: new Date('2025-01-01T10:00:00.000Z'),
    updatedAt: new Date('2025-01-02T15:30:00.000Z'),
  };

  const mockDbUser: DbUser = {
    id: 1,
    email: 'test@example.com',
    name: 'John Doe',
    role: 'user',
    status: 'active',
    isEmailVerified: false,
    passwordHash: 'hashed_password_123',
    createdAt: new Date('2025-01-01T10:00:00.000Z'),
    updatedAt: new Date('2025-01-02T15:30:00.000Z'),
  };

  describe('toResponse', () => {
    it('should convert Date to ISO string', () => {
      const user = User.create(mockUserProps);
      const response = userMapper.toResponse(user);

      expect(response.createdAt).toBe('2025-01-01T10:00:00.000Z');
      expect(response.updatedAt).toBe('2025-01-02T15:30:00.000Z');
      expect(typeof response.createdAt).toBe('string');
      expect(typeof response.updatedAt).toBe('string');
    });

    it('should exclude passwordHash from response', () => {
      const user = User.create(mockUserProps);
      const response = userMapper.toResponse(user);

      expect(response).not.toHaveProperty('passwordHash');
      expect(Object.keys(response)).not.toContain('passwordHash');
    });

    it('should include all required response fields', () => {
      const user = User.create(mockUserProps);
      const response = userMapper.toResponse(user);

      expect(response.id).toBe(1);
      expect(response.email).toBe('test@example.com');
      expect(response.name).toBe('John Doe');
      expect(response.role).toBe('user');
      expect(response.status).toBe('active');
      expect(response.isEmailVerified).toBe(false);
    });

    it('should handle user without createdAt/updatedAt (uses current date)', () => {
      const before = new Date();
      const user = User.create({
        ...mockUserProps,
        createdAt: undefined,
        updatedAt: undefined,
      });
      const response = userMapper.toResponse(user);
      const after = new Date();

      const createdAtDate = new Date(response.createdAt);
      expect(createdAtDate.getTime()).toBeGreaterThanOrEqual(before.getTime());
      expect(createdAtDate.getTime()).toBeLessThanOrEqual(after.getTime());
    });
  });

  describe('toPersistence', () => {
    it('should map domain entity to db model', () => {
      const user = User.create(mockUserProps);
      const dbModel = userMapper.toPersistence(user);

      expect(dbModel.email).toBe('test@example.com');
      expect(dbModel.name).toBe('John Doe');
      expect(dbModel.role).toBe('user');
      expect(dbModel.status).toBe('active');
      expect(dbModel.isEmailVerified).toBe(false);
      expect(dbModel.passwordHash).toBe('hashed_password_123');
    });

    it('should not include id (auto-generated by DB)', () => {
      const user = User.create(mockUserProps);
      const dbModel = userMapper.toPersistence(user);

      expect(dbModel).not.toHaveProperty('id');
    });

    it('should not include timestamps (handled by DB defaults)', () => {
      const user = User.create(mockUserProps);
      const dbModel = userMapper.toPersistence(user);

      expect(dbModel).not.toHaveProperty('createdAt');
      expect(dbModel).not.toHaveProperty('updatedAt');
    });
  });

  describe('toDomain', () => {
    it('should map db model to domain entity', () => {
      const user = userMapper.toDomain(mockDbUser);

      expect(user).toBeInstanceOf(User);
      expect(user.id).toBe(1);
      expect(user.email).toBe('test@example.com');
      expect(user.name).toBe('John Doe');
      expect(user.role).toBe('user');
      expect(user.status).toBe('active');
      expect(user.isEmailVerified).toBe(false);
      expect(user.passwordHash).toBe('hashed_password_123');
    });

    it('should preserve timestamps from db model', () => {
      const user = userMapper.toDomain(mockDbUser);

      expect(user.createdAt).toEqual(new Date('2025-01-01T10:00:00.000Z'));
      expect(user.updatedAt).toEqual(new Date('2025-01-02T15:30:00.000Z'));
    });
  });

  describe('toResponseFromDb', () => {
    it('should convert db model directly to response', () => {
      const response = userMapper.toResponseFromDb(mockDbUser);

      expect(response.id).toBe(1);
      expect(response.email).toBe('test@example.com');
      expect(response.createdAt).toBe('2025-01-01T10:00:00.000Z');
      expect(response).not.toHaveProperty('passwordHash');
    });
  });

  describe('toResponseList', () => {
    it('should map array of users to response array', () => {
      const users = [
        User.create(mockUserProps),
        User.create({ ...mockUserProps, id: 2, email: 'user2@example.com' }),
        User.create({ ...mockUserProps, id: 3, email: 'user3@example.com' }),
      ];

      const responses = userMapper.toResponseList(users);

      expect(responses).toHaveLength(3);
      expect(responses[0].id).toBe(1);
      expect(responses[1].id).toBe(2);
      expect(responses[2].id).toBe(3);
    });

    it('should return empty array for empty input', () => {
      const responses = userMapper.toResponseList([]);

      expect(responses).toHaveLength(0);
      expect(Array.isArray(responses)).toBe(true);
    });

    it('should exclude passwordHash from all items', () => {
      const users = [User.create(mockUserProps), User.create({ ...mockUserProps, id: 2 })];

      const responses = userMapper.toResponseList(users);

      responses.forEach((response) => {
        expect(response).not.toHaveProperty('passwordHash');
      });
    });
  });
});
